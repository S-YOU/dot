#!/usr/bin/env ruby
# encoding: utf-8

#=============================================================================
#   テキストファイルからURLのリストを読み込み、
#   マルチスレッドでhttp getするスクリプト。
#
#   URLリストファイルの仕様
#   ・タブ区切り
#     1. URL（必須）
#     2. ステータスコードの期待値（省略可）
#   ・URLは全て同一ホストでなければならない
#=============================================================================

URL_FILE_EXAMPLE =<<EOF
http://127.0.0.1:8000/employees/
http://127.0.0.1:8000/asd
EOF

require "net/https"
require "uri"

COLOR_RED     = "\x1b[0;31m"
COLOR_GREEN   = "\x1b[0;32m"
COLOR_YELLOW  = "\x1b[0;33m"
COLOR_BLUE    = "\x1b[0;34m"
COLOR_MAGENTA = "\x1b[0;35m"
COLOR_GYAN    = "\x1b[0;36m"
COLOR_RESET   = "\x1b[0m"

COLOR_SUCCESS = COLOR_GREEN
COLOR_WARNING = COLOR_YELLOW
COLOR_FAILURE = COLOR_RED

class TargetUrl
  attr_accessor :url, :expected

  def initialize(url, expected)
    @url = url
    @expected = expected
  end
end

def download(list, thread_id, thread_count)
  if list.length == 0
    return
  end

  uri = URI.parse(list.first.url)

  # Keep-Aliveをつけるので、相手が同一ホストならTCPコネクションは1個しか使われないはず。
  Net::HTTP.start(uri.host, uri.port) do |http|
    count_by_code = Hash.new(0)
    i = thread_id
    started_at = Time.now
    while i < list.length
      url = list[i].url
      expected = list[i].expected

      req = Net::HTTP::Get.new(url)
      req["Connection"] = "Keep-Alive"
      res = http.request(req)

      count_by_code[res.code.to_s] += 1

      # expectedがある場合は、それに一致しているかによって色分け
      if expected
        if res.code.to_s == expected
          color = COLOR_SUCCESS
        else
          color = COLOR_FAILURE
        end
      else
        # expectedがない場合は、ステータスコードに応じて色分け
        case res.code.to_s[0]
        when "5"
          color = COLOR_FAILURE
        when "4"
          color = COLOR_WARNING
        else
          color = COLOR_SUCCESS
        end
      end

      percent = ((i / list.length.to_f) * 100).to_i
      puts "#{color}elapsed:#{Time.now - started_at}\ti:#{i}\tpercent:#{percent}\tstatus:#{res.code}\texpected:#{expected}\turl:#{url}#{COLOR_RESET}\n"

      i += thread_count
    end
    Thread.current[:result] = count_by_code
  end
rescue
  puts "#{COLOR_FAILURE}Error: #{$!.message}#{COLOR_RESET}"
end

def download_list(list, thread_count)
  threads = []
  thread_count.times do |thread_id|
    threads << Thread.new(thread_id) {|thread_id|
      download(list, thread_id, thread_count)
    }
  end

  threads.each {|t| t.join}

  count_by_code = Hash.new(0)
  threads.each do |t|
    t[:result].each do |k, v|
      count_by_code[k] += v
    end
  end
  return count_by_code
end

def main
  if ARGV.length < 1
    puts "Usage: #{$0} <url_file> [<thread_count>]"
    exit 1
  end

  url_file      = ARGV[0]
  thread_count  = (ARGV[1] || "8").to_i

  puts "url_file      = #{url_file}"
  puts "thread_count  = #{thread_count}"
  
  list0 = File.readlines(url_file)
  list = list0.map {|line|
    line.chomp!
    cols = line.split("\t", 2)
    if cols.length >= 2
      TargetUrl.new(cols[0], cols[1])
    else
      TargetUrl.new(cols[0], nil)
    end
  }

  started_at = Time.now
  count_by_code = download_list(list, thread_count)
  puts "完了。所要時間: #{Time.now - started_at} seconds"
  puts "総リクエスト数: #{count_by_code.values.reduce(0) {|s, x| s + x}}"
  p count_by_code
end

main
