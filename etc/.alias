# vim: set ts=4 sts=4 sw=4 et ft=sh: 
# bashとzsh共通のalias

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ,='pushd +1 > /dev/null'
alias ,,='pushd +2 > /dev/null'
alias ,,,='pushd +3 > /dev/null'
alias ,,,,='pushd +4 > /dev/null'
alias bg=' bg'
alias cp='cp -i'
alias com='command'
alias fg=' fg'
alias gdb='gdb -ex start'
alias gti='git'
alias gosh='rlwrap --histsize 10000 -q "\"" --break-chars "(){}[].,#@;|\`\"" -f . -f ~/.vim/dict/schemedict.txt --complete-filenames gosh'
alias la='ls -a'
# ls
case "$OSTYPE" in
    *bsd*)
        alias ls='ls -AG'
        ;;
    *darwin*)
        alias ls='ls -AG'
        ;;
    *)
        alias ls='ls --color=auto'
        ;;
esac
alias ll='ls -lrth'
alias ldir='ls -lrth'
alias lsdot='ls -ld ~/.*'
alias lsdotl='CLICOLOR_FORCE=1 lsdot | grep -e "->"'
alias r='$DOT/bin/r'
alias rm='$DOT/bin/rma.sh'
alias rp='realpath'
alias st='git st'
#alias rm='~/git/rm_alternative/rma.sh'
alias tf='tail -f -n 500'
alias vi='vim'
alias wget='wget --no-check-certificate --content-disposition'
alias xf='xmllint --format - | less'
xpath() {
    xmllint --noent --format --xpath "$1" -
}

man() {
    env LESS_TERMCAP_mb=$'\E[01;31m' \
    LESS_TERMCAP_md=$'\E[01;38;5;197m' \
    LESS_TERMCAP_me=$'\E[0m' \
    LESS_TERMCAP_ue=$'\E[0m' \
    LESS_TERMCAP_us=$'\E[04;38;5;129m' \
    man "$@"
}

l() {
    if [ ! -t 0 ]; then
        less "$@"
    elif [ -d "$1" ]; then
        ls -lrt "$@"
    elif [ -f "$1" ]; then
        less "$@"
    else
        ls -lrt
    fi
}

md() {
    mkdir -p "$1" && cd "$1"
}

ghc() {
    which stack > /dev/null
    if [ $? = 0 ]; then
        stack --verbosity silent ghc -- -O "$@"
    else
        command ghc "$@"
    fi
    command rm *.hi *.o
}

ghci() {
    which stack > /dev/null
    if [ $? = 0 ]; then
        stack --verbosity silent ghci -- "$@"
    else
        command ghci "$@"
    fi
}

runghc() {
    which stack > /dev/null
    if [ $? = 0 ]; then
        stack --verbosity silent runghc -- "$@"
    else
        command runghc -- "$@"
    fi
}

is_screen() {
  case "$TERM" in
    *screen*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

jq() {
    if [ -t 1 ]; then
        OPT="-C"
    else
        OPT=""
    fi
    if [ "$1" = "" ]; then
        set -- .
    fi
    command jq $OPT "$@" | less
}

ps() {
    if [ $# = 0 ]; then
        case "$OSTYPE" in
            *linux*)
                command ps axfo user,pid,pgid,tty,ni,rss,vsz,stat,wchan=WIDE-WCHAN-COLUMN,start,args | less +G
                ;;
            *)
                command ps axo user,pid,pgid,tty,ni,rss,vsz,stat,start,args | less +G
                ;;
        esac
    else
        command ps "$@" | less +G
    fi
}

tt() {
    if [ -t 1 ]; then
        cd $(pjroot)
    else
        pjroot
    fi
}

curljq() {
    curl "$@" | jq .
}

awsenv() {
    if [ "$1" = "" ]; then
        ruby ~/home/bin/awsenv.rb
    else
        eval $(ruby ~/home/bin/awsenv.rb "$@")
        ruby ~/home/bin/awsenv.rb
    fi
}

mv() {
    for last; do true; done
    dir=$(dirname "$last")
    if [ ! -d "$dir" ]; then
        echo "$dir not exist."
        echo -n "Create directory? [y/N]"
        read answer
        if [ "$answer" = "y" ]; then
            mkdir -pv "$dir"
        fi
    fi
    command mv -iv "$@"
}

# 任意のコマンドをlessでページング対応させる関数
pagerize() {
    cmd="$1"
    shift
    src="
    $cmd() {
        if [ -t 1 ]; then
            command $cmd \"\$@\" | less -F
        else
            command $cmd \"\$@\"
        fi
    }
"
    eval "$src"
}

pagerize find
pagerize readelf
pagerize tree

svn() {
    if [ -t 1 -a "$1" = "ci" -o "$1" = "pe" ]; then
        command svn "$@"
    else
        FORCE_COLOR=true command svn "$@" | less -F
    fi
}
gcc-predefined-macros() {
     gcc -v -E -dM - < /dev/null
}

gcc-including-files() {
	`gcc -print-prog-name=cc1` -E -H -quiet "$@" > /dev/null
}

gcc-system-include-path() {
	cpp -v < /dev/null 2>&1 >/dev/null|sed -ne '/#include <.*starts here:/,/End of search list/p' | body 1 1
}

gcc-make-depend() {
	gcc -MM "$@"
}

gcc-make-depend-system() {
	gcc -M "$@"
}

gcc-preprocess() {
    local compile_command=`show-compile-command $1`
    if [ -z "$compile_command" ]; then
        echo "Don't know how to compile: $1" 1>&2
        return 1
    else
        local preprocess_command=`echo "$compile_command"|sed -e 's@cc@cc -E -C@;s@-c@@g;s@-S@@g;s@ -o *[^ ][^ ]*@@g'`
        echo "$preprocess_command" 1>&2
        eval "$preprocess_command"
    fi
}

gcc-show-macros() {
    local compile_command=`show-compile-command $1`
    if [ -z "$compile_command" ]; then
        echo "Don't know how to compile: $1" 1>&2
        return 1
    else
        local preprocess_command=`echo "$compile_command"|sed -e 's@cc@cc -EC -dM@;s@-c@@g;s@-S@@g;s@ -o *[^ ][^ ]*@@g'`
        eval "$preprocess_command"
    fi
}
