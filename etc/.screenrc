# マシン固有の設定は
# ~/.screenrc.local
# に書くこと

escape ^T^T

# vimでEscの反応が遅くなるのを防ぐため
maptimeout 0

# 256色対応
termcapinfo xterm* 'Co#256'
# 背景色設定
termcapinfo xterm* 'AB=\E[48;5;%dm'
# 文字色設定
termcapinfo xterm* 'AF=\E[38;5;%dm'
# F1～F4が効くようにする
termcapinfo xterm* 'k1=\E[11~'
termcapinfo xterm* 'k2=\E[12~'
termcapinfo xterm* 'k3=\E[13~'
termcapinfo xterm* 'k4=\E[14~'
# ハードステータス
termcapinfo xterm* 'hs@'
# xtermの初期化文字列（端末エミュレータのウィンドウサイズが変わらないようにしておく）
termcapinfo xterm* 'is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;4;6l'

# erase/insert/scroll/clear 操作でクリアされるすべての文字は、現在の背景色で表示されることになる
defbce on

defencoding utf8
#encoding utf8 utf8
defscrollback 4000
ignorecase on
startup_message off
vbell off
altscreen on
cjkwidth on
#multiuser on
# Enable non-blocking mode to better cope with flaky ssh connections.
defnonblock 5

# %-w   前のウィンドウ
# %{ }  カラー指定 r赤 g緑 b青 y黄 cシアン mマジェンダ
# %n    ウィンドウ番号
# %t    ウィンドウ名
# %{-}  カラーリセット
# %+w   後のウィンドウ
# %=    パディング
# %l    システム負荷
#
# %? A  %?    条件Aが真ならAを表示
# %? B %: C %?    条件Bが真ならBを、偽ならCを表示
hardstatus alwayslastline "[%H] %-w%{.b}%n %t%{-}%+w %=%?%E%{.b} C-t %{-}%?"
caption splitonly "%?%F%{.b}%?%n %t"

bind H
# hardcopyは文字化けするのでこの方法で
# bind h eval "readreg t" "msgminwait 0" "copy" "stuff \"H L$ \"" "writebuf $HOME/hardcopy.txt" "paste t ."
bind h eval "hardcopy -h $HOME/hardcopy.txt"
bind ^k eval "focus up"
bind ^j eval "focus down"
bind ^b eval copy "stuff H"        # C-bだけでコピーモードに入れるようにする
bind ? eval copy "stuff ?"
bind ^v eval readbuf "paste ."      # Vimでヤンクしたテキストを貼り付ける
bind . source $HOME/.screenrc
bind + resize +5
bind - resize -5
bind = resize =
bind w remove                       # ブラウザと同じC-w
bind ^w remove                      # ブラウザと同じC-w
bind q remove                       # ブラウザと同じC-w
bind o only
bind ^o only
bind S eval "split"    focus next next      # 分割
bind | eval "split -v" focus next next      # 縦分割

### C-tなしでのバインディングをするにはbindkeyを使う
# Pageup, Pagedownでウィンドウ切り替え
bindkey "^[[5~" prev
bindkey "^[[6~" next
bindkey "^[p" prev
bindkey "^[n" next
bindkey "^[[" copy
bindkey "^[]" paste .
bindkey "^[K" eval focus "stuff ^[k" focus

# F11 F12. vim起動中も有効にするためには、-aつきでも定義しないといけない
#bindkey -k -a F1 prev
#bindkey -k -a F2 next

# Vimでヤンクしたテキストを貼り付けるため
setenv BUFFERFILE "$HOME/.yank" 
bufferfile "$BUFFERFILE"

#markkeys ^K=3k

# いくつかウィンドウを開いておく
#screen
#screen -t db 1
#screen -t *mini* 9
#select 0

# backtick の例
# caption always "%0`"
# backtick 0 5 5 vmstat
# backtick 1 60 60 date +'%H:%M'

# レイアウト
# C-t Y でレイアウトモードを開始する
bind Y source $HOME/.screenrc.layouts
# C-t C-y C-m で右のリージョンで前回のコマンドを再実行する
bind -c layout ^M eval focus "stuff ^P^M" focus
# C-t C-y C-v で右のリージョンにVimのレジスタ内容を貼り付ける
bind -c layout ^V eval readbuf focus "paste ." "stuff ^M" focus

# http://yskwkzhr.blogspot.jp/2011/12/guide-to-using-gnu-screen-layouts.html
# trigger for layout sub-commands
bind ^Y eval 'command -c layout' 'layout show'
bind y  eval 'command -c layout' 'layout show'

# create/remove layout
bind -c layout c eval 'layout new'    'layout show'
bind -c layout X eval 'layout remove' 'layout show'

# change the current layout title or number
bind -c layout A colon 'layout title '
bind -c layout N colon 'layout number '

# switch to the layout identified by number or title (not prefix of a title)
bind -c layout \' eval 'layout select' 'layout show'

# switch to other layout
bind -c layout n eval 'layout next'     'layout show'
bind -c layout p eval 'layout prev'     'layout show'
bind -c layout 0 eval 'layout select 0' 'layout show'
bind -c layout 1 eval 'layout select 1' 'layout show'
bind -c layout 2 eval 'layout select 2' 'layout show'
bind -c layout 3 eval 'layout select 3' 'layout show'
bind -c layout 4 eval 'layout select 4' 'layout show'
bind -c layout 5 eval 'layout select 5' 'layout show'
bind -c layout 6 eval 'layout select 6' 'layout show'
bind -c layout 7 eval 'layout select 7' 'layout show'
bind -c layout 8 eval 'layout select 8' 'layout show'
bind -c layout 9 eval 'layout select 9' 'layout show'

bind ^v eval readbuf "paste ."      # Vimでヤンクしたテキストを貼り付ける

# continuous switch to other layout
bind -c layout ^N eval 'layout next' 'command -c layout' 'layout show'
bind -c layout ^P eval 'layout prev' 'command -c layout' 'layout show'

source $HOME/.screenrc.local
